#*******************************************
# MacVersion = 1.05 alpha
# MacDescription = Breaking a regional database into sensible subregions for geocaching
# MacAuthor = Heiner Lieth (Hynr)
# MacFileName = Geotile.gsk
# MacUrl =
#*******************************************
VerCheck Version=7.6.2.00
Gosub Name=VariableDeclarations
$Version="1.05 alpha"

#IF $_Count>2000
#Pause msg="Note: There are $_Count records in the display grid.$_NewLine Do you really want to continue?"
#Endif

$PauseForm=Replace("Geotile.gsk","Geotile.gsk ver $Version",$PauseForm)
$MainForm=Replace("Geotile.gsk","Geotile.gsk ver=$Version",$MainForm)
#Preamble - warn user that some time consuming calculations are coming up and give 
# opportunity to cancel out if this macro was started in error
  $PauseFormMemo="This macro processes all the data that are currently in your$_NewLine display grid. "
  $PauseFormMemo=$PauseFormMemo+"This is likely to be time consuming, especially if$_NewLine you have "
  $PauseFormMemo=$PauseFormMemo+"a large database displaying without any filters.$_NewLine$_NewLine"
  $PauseFormMemo=$PauseFormMemo+"Running this macro involves 2 step: first the data are grouped$_NewLine into groups (called Tiles)."
  $PauseFormMemo=$PauseFormMemo+" Once you have it the way you like it,$_NewLine you can then do things with these Tiles.$_NewLine$_NewLine"
  $PauseFormMemo=$PauseFormMemo+"Click Continue to run a preliminary analysis using the $_Count$_NewLine"
  $PauseFormMemo=$PauseFormMemo+" records in the current display grid. "
  $PauseFormMemo=$PauseFormMemo+"While the macro works with $_NewLine any number of records, it is designed"
  $PauseFormMemo=$PauseFormMemo+" for data sets with$_NewLine recordnumbers between 500 and 50,000.$_NewLine$_NewLine"
  $PauseFormMemo=$PauseFormMemo+"This GSAK macro was written by Heiner Lieth, December 2009"
# remove Yes and No buttons from pauseform since it will confuse the user
  $PauseForm = EditForm($PauseForm,"PauseFormYesButton","Visible","No")
  $PauseForm = EditForm($PauseForm,"PauseFormNoButton","Visible","No")
#  gosub Name=PauseForm
  $PauseForm = EditForm($PauseForm,"PauseFormYesButton","Visible","Yes")
  $PauseForm = EditForm($PauseForm,"PauseFormNoButton","Visible","Yes")

<data> VarName=$GTinstructions

# ============ Operating Instructions for this Macro: =================

# Note that the fields on the form contain data which you can adjust.
# Then click "Tile" button and consider the results. You can then change the numbers and recalculate. 
# After the tiles have been created, several actions and options will appear on the form. 
# Once the tiles are layed out to your satisfaction, create the export.
# For PN-30/40 GPSrs running firmware 2.7 you may load the DeLorme gpx files directly to the unit by
# putting it in "Trasfer to SD card" mode (under "Device Setup", "Connect to Computer")
# and having the files end up directly in the gpx folder on the SD card in the unit.

# ============ Description of Macro:  =================================

# This macro creates regionional subdatabases out of a large database by "tiling" the geographic
# region so that each "Tile" is

# - rectangular

# - respects a user-specificed number of geocaches as well as a max total number (caches+other waypoints)

# - if child waypoints are included, then tiles are adjusted to not exceed hard maximum number of waypoints

# You may wonder why the method used by this macro is so complex. Note that the motivation is as follows. 
# The GPSr holding these files will be used for geocaching so that you will be traveling from one 
# rectangular area into the other. It will be important to have a clue as to which tile you need
# to select as you move from one Tile to the next.
# But you cannot simply make all the tiles the same size (regular grid) because some tiles will 
# exceed the maximum number allowed (e.g in urban areas). 

# It is assumed that there is some number of caches that cannot be exceeded
# due to hardware restrictions (e.g. 1000 waypoints). And that the user would 
# prefer to stay below that for some other reasons (slow operation, keep room 
# available for setting waypoints in the field or for child waypoints). 

# The design of the macro is for databases where the number of caches is significantly
# greater than 10 times the MaximumNumber

# It is worthwhile visualizing the data as in the figure:
# Let us assume that there are many thousands of
# geocaches; note there is a regional center and rectangular "bounding box" around this region.
# Displaying the database on a map would appear as a big blob. 
# So now envision just the data in the bounding box.

# Envision a North-south line through the bounding box, bisecting it into
# two rectangles: an East side and a West side. (each with a different numnber of caches)
# Further envision deviding each of these rectangles into bands running parallel to the latitudes.
# The method here goes through each band and selects
# as many rectangles as are needed for each to include all the geocaches in that band.
# These rectangles "tile" the bounding box; gaps between the tiles contain no geocaches;
# The north-south dimension of each tile is the same; east-west dimension varies.

<enddata>
###################### USER DATA SECTION ################################################

  $GT_MaximumNumber = 1000  #the absolute maximum number of caches in any one region
			    # (hardware max) 1000 for DeLorme PN-40
  $GT_MagicNumber = 650     #the maximum number of geocaches desired (soft max)

########### INITIALIZATION (users should not need to modify anything in this section #####

  $StatusMessage="Setting things up - Please wait, this will take a minute or two [SQLinit]"
  Gosub Name=StatusDisplay


# Create the SQL table that will be used to do all the calculations
  $SQLfields= "Code, Latitude, Longitude, CacheType, Symbol "
  $SQLdatabase="$_AppData\macros\Test.db3"
  $TMPstr=DbToSQLite("caches",$SQLfields,$SQLdatabase)
  $TMPstr=sqlite("open","$SQLdatabase")       
# We need the full cachetype name because the PN gpsr needs this, so we'll start with:
# Since we will be doing a lot of math with lat and lon, create NrLatitude and NrLongitude as type real
  $_SQL= "Attach '$_ExePath\static.db3' as static; attach '$_CurrentDataPath\sqlite.db3' as gsakdb;"
  $SQLresult=sqlite("sql",$_SQL,"")
  $_SQL= "Drop Table if Exists GeotileCaches;"
  $SQLresult=sqlite("sql",$_SQL,"")
  $SQLfields=           " Code, Cast(Latitude as Real) as NrLatitude,  "
  $SQLfields=$SQLfields+" Cast(Longitude as Real) as NrLongitude,"  
  $SQLfields=$SQLfields+" Symbol as FullType,"  # Symbol is generally Geocache, blank or some other word or 
  $SQLfields=$SQLfields+" '' as TileName,"  
  $SQLfields=$SQLfields+" CacheType"  # must have this
  $_SQL= "Create Table GeotileCaches as Select $SQLfields from Caches;"
  $SQLresult=sqlite("sql",$_SQL,"")

# The above step set up the FullType column and it currently contains some text that
#  acts as default for those records where the following makes no change
  $_SQL= "UPDATE GeotileCaches SET FullType = (SELECT d2 FROM static.lookup WHERE type='CacheTypes' AND vfrom = CacheType)"
  $SQLresult=sqlite("sql",$_SQL,"")
  # since DeLorme does not know how to spell "Wherigo" we need to make this adjustment:
  $_SQL= "UPDATE GeotileCaches SET FullType = 'Whereigo Cache' WHERE CacheType='I'"
  $SQLresult=sqlite("sql",$_SQL,"")

#  $_SQL="Select * from GeotileCaches;"
#  $SQLresult=sqlite("sql",$_SQL,"")

  # Setup sql table for the tiles that will result from this macro run
  $_SQL=       "Drop Table if Exists Geotiles; "
  $SQLfields="TileName text, CacheCount integer, ChildCount integer, MinLat real, MaxLat real, MinLon real, MaxLon real"
  $_SQL= $_SQL+"Create Table Geotiles ( $SQLfields ) ;"
  $SQLresult=sqlite("sql",$_SQL,"")

  $_SQL= "Select count(*) From GeotileCaches"
  $TotalCacheCountStr=sqlite("sql",$_SQL)
  $MainForm = EditForm($MainForm,"TotalCacheCountEdit","Caption","$TotalCacheCountStr")
  $TotalCacheCount=val($TotalCacheCountStr)
  $StatusMessage="Note there are $TotalCacheCount geocaches that will be processed"
  Gosub Name=StatusDisplay

  $LineFeed=chr(10)  # PN40 seems to use just linefeed to mark new lines

# Initialize various form elements and various routines based on current display grid
# and based on currently selected record

  $MaxLogNrEdit = "9"
  $IncludeAddtnl= true

#  Initialize variables needed to do the DeLorme file generation
  $DeLormeGPX_Folder="$_AppData\macros\gpx"
  $DeLormeDraw_Folder="$_AppData\macros\gpx"
  $KMLFolder="$_AppData\macros\gpx"
  $SetNameEdit="Tmp"

# initialize the form elements:
  $HardMaxEdit="$GT_MaximumNumber"
  $SoftMaxEdit="$GT_MagicNumber"
  $MaxLogNr = val($MaxLogNrEdit)
  $memo2=Replace($_NewLine+"# "+$_NewLine,"@LF@",$GTinstructions)
  $memo2=Replace($_NewLine+"# "," ",$memo2)
  $memo2=Replace("@LF@",$_NewLine+$_NewLine+"     ",$memo2)

  $MainForm = EditForm($MainForm,"OptionsGroup","Visible","No")
  $MainForm = EditForm($MainForm,"Visualize","Visible","No")
  $MainForm = EditForm($MainForm,"DeLormeButton","Visible","No")

# Restore settings to replace the defaults with values that were used the last time
  Macsettings Type=R FileCheck=N

  Gosub Name=CalculateBoundingBox

# Approximate the ideal number of bands
  $BandNumber=Round(1+sqrt($TotalCacheCount/$GT_MagicNumber)/2 , 0)
  IF $BandNumber<1
    # if this is less than 1, then the program will have problems
    $BandNumber=1
  Endif
  $BandNumberEdit="$BandNumber"
  $TMPkml=""

  $StatusMessage="Setting things up - Please wait, this will take a minute or two [BMPinit]" 
  Gosub Name=StatusDisplay

#  The BMP image is generally 600 x 600 although the canvas is a bit bigger (620x620) so that
#  we can be lazy and not check for overflow of the canvas at every possible instance (eg edges
#  of symbols or orther graphic elements. The image seen on the form consists of two BMP layers,
#  one the back layer (on which the background, grid lines, etc), the other is the Front layer
#  for displaying objects that should always be seen over anything that is on the back layer.
#  Never call any of the BMP routines unless you have done the following to set colors, sizes etc
  Gosub Name=BMPinitialization
  Gosub Name=CalculateBoundingBox
  $BMP_BB_N=Round(val($BB_Nedit),2)
  $BMP_BB_S=Round(val($BB_Sedit),2)
  $BMP_BB_E=Round(val($BB_Eedit),2)
  $BMP_BB_W=Round(val($BB_Wedit),2)
# note that the Center point is initiallized to be the center of the data culster
# user may change this pivotal point later
  $BMP_Y=$CenterLat
  $BMP_X=$CenterLon

# Calculate the relative reference to the BMP image canvas
  Gosub Name=BMPSetRelative 

# Draw all the caches in the current filter onto the front canvas
  $BMP_Array=$BMP_ArrayFront
  $BMP_ColorNr=$BMP_ColorNrBlue
  Gosub Name=BMPDrawDisplayGrid

# Here we draw the bounding box the same way any rectangle would be drawn:
# Drawing Bounding box (thin) and reference line (thick), both on the back
  $BMP_Array=$BMP_ArrayBack
  Gosub Name=DrawBBandReferenceLon

#now draw into the Form so that it can show the graphic when it is displayed
#  use the provided MimeEncoded BMP header
  $BMP620square=MimeDecode($BMP620HeadMime)

# Save the background image so it can be restored during experimental tiling
  $BMP_icnt=1
  While $BMP_icnt<=$BMP_PixMax
    Array($BMP_ArrayBack2,$BMP_icnt)=Array($BMP_ArrayBack,$BMP_icnt)
  $BMP_icnt=$BMP_icnt+1
  endwhile
  $BMP_CacheNames=$BMP_labels
  $BMP_labels=""

# Display Form and stay inside this while loop for the duration of the macro execution
#  
  $GT_KeepRunning = true

  While $GT_KeepRunning # Infinite loop to redisplay form as required
    $StatusMessage="Displaying the form" 
    Gosub Name=StatusDisplay

    # Assemble the front image layer
    $BMP_TMPstr= $BMP620square + Array($BMP_ArrayFront,-1)
    $GraphAreaFront=MimeEncode($BMP_TMPstr)
    # Assemble the back image layer
    $BMP_TMPstr= $BMP620square + Array($BMP_ArrayBack,-1)
    $GraphAreaBack=MimeEncode($BMP_TMPstr)

   # Process some of the form checkboxes and comboboxes which are set to exit the form when changed
   IF $BMP_DisplayBackCheck
	$MainForm=EditForm($MainForm,"GraphAreaBack","Visible","Yes")
     else
	$MainForm=EditForm($MainForm,"GraphAreaBack","Visible","No")
   endif
   IF $BMP_DisplayFrontCheck
	$MainForm=EditForm($MainForm,"GraphAreaFront","Visible","Yes")
     else
	$MainForm=EditForm($MainForm,"GraphAreaFront","Visible","No")
   endif
   # Insert the comments between the front and back image
   #####################  AND DISPLAY THE FORM ########################
   IF $BMP_DisplayLabels
	$MainFormWithLabels=replace("Name=GraphAreaFront","$BMP_CacheNames $BMP_labels Name=GraphAreaFront",$MainForm)
	$FormExit = form($MainFormWithLabels,"")
    Else
	$MainFormWithLabels=replace("Name=GraphAreaFront","$BMP_labels Name=GraphAreaFront",$MainForm)
	$FormExit = form($MainFormWithLabels,"")
   Endif
   # Now process the exit codes: which button was pressed and how should GSAK react
   BeginCase

     Case $FormExit = "BBbutton"
	# User expects BBbutton click to result in recalcuation of bounding box
#	Gosub Name=CalculateBoundingBox
	# this also recalculates the reference longitude (the user might not be expecting that)
	$BMP_BB_N=Round(val($BB_Nedit),2)
	$BMP_BB_S=Round(val($BB_Sedit),2)
	$BMP_BB_E=Round(val($BB_Eedit),2)
	$BMP_BB_W=Round(val($BB_Wedit),2)
	#Clear the two background images
	  $BMP_icnt=1
	  $BMP_TmpStr=""
	  $BMP_TMPStrBack=""
	  While $BMP_icnt<=$BMP_PixMax
	   $BMP_TMPstr=$BMP_TMPstr+chr($BMP_ColorTransparent)
	   if $BMP_ShowGridLines and (frac($BMP_iCnt/20)=0)
	     $BMP_TMPstrBack=$BMP_TMPstrBack+chr($BMP_ColorGridLine)
	   else 
	     $BMP_TMPstrBack=$BMP_TMPstrBack+chr($BMP_ColorBackground)
	   endif
	   $BMP_icnt=$BMP_icnt+1
	  endwhile
	# set up the data structures for the BMP back layer
	  Array($BMP_ArrayBack,-1)=$BMP_TMPstrBack
	# we need the following so we can reset the canvas without recalculating all this
	  Array($BMP_ArrayBack2,-1)=$BMP_TMPstrBack
	#horizontal grid lines every 20 rows on the backdrop but only
	  if $BMP_ShowGridLines
	    $BMP_GridLine=Replace(chr($BMP_ColorTransparent),chr($BMP_ColorGridLine),$BMP_TMPstr)
	    $BMP_icnt=20
	    While $BMP_icnt<=$BMP_PixMax
	     Array($BMP_ArrayBack,$BMP_icnt)=$BMP_GridLine
	     Array($BMP_ArrayBack2,$BMP_icnt)=$BMP_GridLine
	     $BMP_icnt=$BMP_icnt+20
	    endwhile
	  endif
	$BMP_Array=$BMP_ArrayBack
	Gosub Name=DrawBBandReferenceLon
	# Save the background image so it can be restored during experimental tiling
	$BMP_icnt=1
	While $BMP_icnt<=$BMP_PixMax
	  Array($BMP_ArrayBack2,$BMP_icnt)=Array($BMP_ArrayBack,$BMP_icnt)
	$BMP_icnt=$BMP_icnt+1
    	endwhile
	$BMP_labels=""
 
     Case $FormExit = "TileButton"
        # The user has requested to tile the region.
	# we need to restore the background to remove any previously calculated tiles
	$BMP_icnt=1
	While $BMP_icnt<=$BMP_PixMax
	  Array($BMP_ArrayBack,$BMP_icnt)=Array($BMP_ArrayBack2,$BMP_icnt)
	$BMP_icnt=$BMP_icnt+1
    	endwhile
	# also clear the tile labels
	$BMP_labels=""
	# Note that ProcessBands does all the area; 
	Gosub Name=ProcessBands
	# now that this is done, we need to change the form to show the result and to 
	# get things ready so that the user could take approriate action

	# make instruction box invisible and display options
        $MainForm = EditForm($MainForm,"Memo2","Visible","No")
	# show these elements to the user so choices can be made:
	$MainForm = EditForm($MainForm,"OptionsGroup","Visible","Yes")
	$MainForm = EditForm($MainForm,"Visualize","Visible","Yes")
	$MainForm = EditForm($MainForm,"DeLormeButton","Visible","Yes")

     Case $FormExit = "DeLormeButton"
	Gosub Name=Do_DeLormeGPX

     Case $FormExit = "VisualizeButton"
	#do the exports that have been programmed (other than special DeLorme gpx export)
	Gosub name=Visualization

    Case $FormExit = "SystemExit"
	$GT_KeepRunning=false
	Break

    Case $FormExit = "QuitButton"
	# Form exit from the Exit button
	if $_CtrlKey 
	# If Control is held as Exit button is pressed and released: loads the form into the clipboard for editing
	  $TmpStr="<Data> VarName=$"+"MainForm $_NewLine" + $MainForm + $_NewLine + "<enddata>"
	  Clip data="$TmpStr"
	  Pause msg="Data loaded into clipboard:$_NewLine$TmpStr"
	endif
	$GT_KeepRunning=false

    Case $FormExit = "DelayExit"
	MsgOk msg="Form exit via Delay"
	$GT_KeepRunning=false

   EndCase
  EndWhile	# $GT_KeepRunning

#Exit 
# Clean-up
  ShowStatus Display=Off
  Macroflag type=clear range=all

  $_SQL= "Drop Table if Exists GeotileCaches;"
  $SQLresult=sqlite("sql",$_SQL,"")
  MacSettings Type=S Vars=SetNameEdit,DrawLayerCreate,HardMaxEdit,SoftMaxEdit,MaxLogNrEdit,DeLormeGPX_Folder,GoogleEarthCheckbox,KMLfolder,DeLormeDraw_Folder
Cancel

############################################################ Subroutines ##########

Beginsub Name=Do_DeLormeGPX
# If the user's folder does not exist, then try to create it
  IF Not(FolderExists($DeLormeGPX_Folder))
   $TMPstr = PutFile("$_Install\babel.bat", "MD " + quote($DeLormeGPX_Folder))
   IF Left($TMPstr,7) = "*Error*"
     Pause Msg="Cancelling: Could not create folder $DeLormeGPX_Folder"
     Cancel
   ENDIF
   FileOpen File="$_Install\babel.bat" Wait=yes
  ELSE
   # If the folder was already there, see if we need to delete some files
   $TMPstr=trim($SetNameEdit)
   $TmpStr=$DeLormeGPX_Folder+"\$TMPstr*.gpx"
   IF FileExists($TmpStr)
	$PauseFormMemo="$TmpStr $_Newline files exist - would you like to delete them?"
	#remove continue button from pauseform since it will confuse the user
	$PauseForm = EditForm($PauseForm,"PauseFormContinueButton","Visible","No")
	gosub Name=PauseForm
	$PauseForm = EditForm($PauseForm,"PauseFormContinueButton","Visible","YES")
	if $PauseForm_YesNo
	  #delete exisiting files that match the wildcard
	  FileErase file=$TMPstr OnError=Prompt
	endif
   endif
  ENDIF
# interrogate Geotiles table and create files in accordance
  $iTile=1
  $_SQL= "Select count(*) from Geotiles;" 
  $iTileMax=val(sqlite("sql",$_SQL))
  While $iTile<=$iTileMax
     $SQLfields="TileName, CacheCount, ChildCount, MinLat, MaxLat, MinLon, MaxLon"
     $_SQL= "Select $SQLfields from Geotiles where ROWID=$iTile"
     $SQLresult=sqlite("sql",$_SQL,"")
     $TileSpecs=extract($SQLresult,";",1)
     $MinLat=val(extract($SQLresult,";",4))
     $MaxLat=val(extract($SQLresult,";",5))
     $MinLon=val(extract($SQLresult,";",6))
     $MaxLon=val(extract($SQLresult,";",7))
     $_SQL= "Select code from GeotileCaches where (NrLatitude>=$MinLat) and (NrLatitude<=$MaxLat)"
     $_SQL=$_SQL+ " and (NrLongitude>=$MinLon) and (NrLongitude<=$MaxLon)"
     $TileGCcodes=sqlite("sql",$_SQL,"")
     $TileGCcodesNR=1+RegExCount($_NewLine,$TileGCcodes)
#    pause msg="$iTile tile of $iTileMax spec: $TileSpecs ($TileGCcodesNR)$_NewLine$TileGCcodes"
     $DeLormeGPX_Filename=$TileSpecs 
     Gosub Name=CreateDeLormeGPX
     $iTile=$iTile+1
  endwhile
endsub

Beginsub Name=CreateDeLormeGPX
  ShowStatus msg="$iTile tile of $iTileMax: $DeLormeGPX_Filename"
  $DeLormeGPX_String="<name>$DeLormeGPX_Filename</name>"
  $bigStr = addstr(1,"clear")
  $bigStr = addstr(1,"add",$DeLormeGPX_Header)
  $bigStr = addstr(1,"add",$DeLormeGPX_String)
  #Compose the SQL queries (no need to do this within the loop:
    # Create mashup for this cache where we later replace 
    # semicolons with LineFeeds, @Qt@ are double quotes
    # at end: convert "&nbsp;" to " "
    $_SQL= "SELECT '@lt@wpt lat=@Qt@' || latitude || '@Qt@ lon=@Qt@' || longitude || '@Qt@@gt@@LF@'"
    $_SQL= $_SQL+ " || ' @lt@ele@gt@-2000000.000000@lt@/ele@gt@'"
    $_SQL= $_SQL+ " || '@LF@ @lt@time@gt@' || strftime('%Y-%m-%d',PlacedDate) || 'T08:00:00Z@lt@/time@gt@'"
    $_SQL= $_SQL+ " || '@LF@ @lt@name@gt@' || name || '@lt@/name@gt@'"
    $_SQL= $_SQL+ " || '@LF@ @lt@sym@gt@@FullType@@lt@/sym@gt@'"
    $_SQL= $_SQL+ " || '@LF@ @lt@desc@gt@' || Name || ' by ' || PlacedBy"
    $_SQL= $_SQL+ " || '@LF@Cache ID: ' || code"
    $_SQL= $_SQL+ " || '@LF@@FullType@' "
    $_SQL= $_SQL+ " || '@LF@SIZE: ' || container"
    $_SQL= $_SQL+ " || '@LF@D' || Difficulty || '/T' || Terrain || '@LF@DESC: '"
    $_SQL= $_SQL+ " || '@BIGTEXT@@LF@Placed: ' || PlacedDate"
    $_SQL= $_SQL+ " || '@LF@LOG: @LF@' "
    $SQLqueryA= $_SQL+ " from CachesTemp "
  # and do first part of SQL query for the logs:
    $_SQL="SELECT lType, '@1', "
    $_SQL= $_SQL+"strftime('%Y-%m-%d',lDate), '@2', lBy, '@3', lText "
    $SQLqueryB= $_SQL+"FROM LogsAll "
    #pause msg="$iTile tile of $iTileMax spec: $TileSpecs ($TileGCcodesNR)"

  $iCount=1
  While $iCount<=$TileGCcodesNR
    IF frac($iCount/20) = 0
     ShowStatus msg="$iTile tile of $iTileMax: $DeLormeGPX_Filename record $iCount of $TileGCcodesNR"
    endIf
    $GCcode=Extract($TileGCcodes,$_NewLine,$iCount)
    $_SQL= $SQLqueryA + " WHERE code = '$GCCode' "
    $SQLresult=sqlite("sql",$_SQL,"delimcvt=@!@ crlfcvt=@LF@")

    $_SQL= "SELECT g_RegexReplace('(?s:<.*?>)', shortdescription ||'@LF@' || longdescription ||'@LF@Hint: ' || hints, '')"
    $_SQL= $_SQL + " From CacheMemo WHERE code = '$GCCode' "
    $TMPstr=sqlite("sql",$_SQL,"delimcvt=@!@ crlfcvt=@LF@")
    $SQLresult=Replace("@BIGTEXT@",$TMPstr,$SQLresult)

    $_SQL= "SELECT FullType "
    $_SQL= $_SQL + " From GeotileCaches WHERE code = '$GCCode' "
    $TMPstr=sqlite("sql",$_SQL,"delimcvt=@!@ crlfcvt=@LF@")
    $SQLresult=Replace("@FullType@",$TMPstr,$SQLresult)

    $_SQL= $SQLqueryB+"WHERE lParent = '$GCCode' ORDER BY lDate DESC, lLogId DESC LIMIT $MaxLogNr"
    $TheLogs=sqlite("sql",$_SQL,"delimcvt=@!@ crlfcvt=@LF@")
    $SaniString="$SQLresult$TheLogs@LF@"
    Gosub Name=Sanitize
    $bigStr = addstr(1,"add","$SaniString</desc></wpt>$LineFeed")
    $iCount=$iCount+1
  endwhile

  If $IncludeAddtnl
   # do all additional waypoints at once
    gosub Name=DeLormeGPX_additional
    $bigStr = addstr(1,"add",$Addnt)
  Endif

  $bigStr = addstr(1,"add",$DeLormeGPX_Footer)
  $bigStr = addstr(1,"get")
  $bigStr = Replace(";@1;",$LineFeed,$bigStr)
  $bigStr = Replace(";@2;"," ",$bigStr)
  $bigStr = Replace(";@3;",", ",$bigStr)
  $bigStr = Replace("@!@",";",$bigStr)
  $bigStr = Replace("@gt@",">",$bigStr)
  $bigStr = Replace("@lt@","<",$bigStr)
  $bigStr = Replace("@Qt@",$_Quote,$bigStr)
  $bigStr = Replace($_NewLine,$LineFeed,$bigStr)
  $bigStr = Replace("@LF@",$LineFeed,$bigStr)
  #   Pause Msg="writing $DeLormeGPX_Folder\$DeLormeGPX_Filename.gpx"
  $DataRes = PutFile("$DeLormeGPX_Folder\$SetNameEdit $DeLormeGPX_Filename($TileGCcodesNR).gpx",UTF8($bigStr,"e"))
  IF Left($DataRes,7) = "*Error*"
    Pause Msg="$DataRes"
    Cancel
  ENDIF
endsub

beginsub Name=DeLormeGPX_additional
  $FromStr=" FROM WayAll where cParent in ('"+Replace($_NewLine,"','",$TileGCcodes)+"')"
  $_SQL= "Select count(*) "+$FromStr
  $AddntCount=val(sqlite("sql",$_SQL))
  If $AddntCount>0
    $_SQL= "SELECT '@1@', clat,'@2@', clon, '@3@',date(cDate)||'T08:00:00Z', "
    $_SQL= $_SQL+"'@4@', cName, '@5@', cType, '@6@',"
    $_SQL= $_SQL+" cComment||' {'||cCode||' for:'||cParent||'}','@7@'"+$FromStr
    $SaniString=sqlite("sql",$_SQL,"delimcvt=@!@ crlfcvt=@LF@")
    Gosub Name=Sanitize
    # Now turn the SQL returned text into xml:
    $Addnt=Replace("@1@;" ,"<wpt lat=$_Quote",$SaniString)
    $Addnt=Replace(";@2@;","$_Quote lon=$_Quote",$Addnt)
    $Addnt=Replace(";@3@;","$_Quote>$_NewLine <ele>-2000000.000000</ele>$_NewLine <time>",$Addnt)
    $Addnt=Replace(";@4@;","</time>$_NewLine <name>",$Addnt)
    $Addnt=Replace(";@5@;","</name>$_NewLine <sym>",$Addnt)
    $Addnt=Replace(";@6@;","</sym>$_NewLine <desc>",$Addnt)
    $Addnt=Replace(";@7@" ,"</desc>$_NewLine</wpt>",$Addnt)
  else
    $Addnt=""
  Endif
endsub

Beginsub Name=CalculateBoundingBox
# Recalculate bounding box and reference line for display grid
  $_SQL= "Select max(NrLatitude) from GeotileCaches"
  $BB_Nedit=sqlite("sql",$_SQL)
  $_SQL= "Select min(NrLatitude) from GeotileCaches"
  $BB_Sedit=sqlite("sql",$_SQL)
  $_SQL= "Select max(NrLongitude) from GeotileCaches"
  $BB_Eedit=sqlite("sql",$_SQL)
  $_SQL= "Select min(NRLongitude) from GeotileCaches"
  $BB_Wedit=sqlite("sql",$_SQL)
  $CenterLon = (val($BB_Eedit)+val($BB_Wedit))/2
  $Referencelon="$CenterLon"
  $CenterLat = (val($BB_Nedit)+val($BB_Sedit))/2
endsub

Beginsub Name=ProcessBands
# The collection of items is bounded by a bounding box and a 
  $RefLongitude=val($Referencelon)
  $BB_N=val($BB_Nedit)
  $BB_S=val($BB_Sedit)
  $BB_E=val($BB_Eedit)
  $BB_W=val($BB_Wedit)
# trap condition where reference line is not in the bounding box
  if $RefLongitude < $BB_W
    $RefLongitude=$BB_W
    $Referencelon = "$RefLongitude"
  endif
  if $RefLongitude > $BB_E
    $RefLongitude = $BB_E
    $Referencelon = "$RefLongitude"
  endif
  $BandNumber=val($BandNumberEdit)
  if $BandNumber<1 
    $BandNumber=4  #if invalid data caused this to be zero, then set it to 4
    $BandNumberEdit="$BandNumber"
  endif
  $GT_MaximumNumber=val($HardMaxEdit)
  $GT_MagicNumber=val($SoftMaxEdit)
  $iCacheGroup=1
# empty the Geotiles table
  $_SQL= "DELETE FROM Geotiles; "
  $_SQL= $_SQL+"Select count(*) from GeotileCaches"
  $SQLresstr=sqlite("sql",$_SQL)
  $TotalNrCaches=val($SQLresstr)

  $SIDE="E"
  Gosub Name=ProcessBand
  $SIDE="W"
  Gosub Name=ProcessBand

# Go ahead and draw the tiles
# Now draw the tiles on this back image
    # Process every row in the Geotiles table
    # How many tiles are there in the list
    $BMP_Array=$BMP_ArrayBack

    $_SQL= "Select count(*) from Geotiles;" 
    $TotalNrTiles=val(sqlite("sql",$_SQL))
    $RowNr=1
    $BMP_ColorNr=8
#  $BMP_LineThick=false
    $SQLfields="TileName, CacheCount, ChildCount, MinLat, MaxLat, MinLon, MaxLon"
    While $RowNr<=$TotalNrTiles
      $_SQL= "Select $SQLfields FROM Geotiles WHERE ROWID=$RowNr ;"
      $TmpStr=sqlite("sql",$_SQL,"")
      ShowStatus msg="$RowNr: Processing Tile $TmpStr"
      $BMP_BBrectLabel=extract($TmpStr,";",1)
      $BMP_BBrectS=val(extract($TmpStr,";",4))
      $BMP_BBrectN=val(extract($TmpStr,";",5))
      $BMP_BBrectW=val(extract($TmpStr,";",6))
      $BMP_BBrectE=val(extract($TmpStr,";",7))
      $BMP_BBrectFill=false
      $BMP_ColorNr=$BMP_ColorNr+1
      Gosub Name=BMPDrawBBRectangle
      $RowNr=$RowNr+1
      if $BMP_ColorNr=14
        $BMP_ColorNr=8
      endif
    endwhile
endsub

Beginsub Name=ProcessBand
# Note that this subroutine has a very similar name to the one that calls it (above)
# the following handles either the East side or the west side of the region depending on
# the value of $SIDE

  # start by creating a new view in the SQL database 
  $_SQL= "Drop View IF EXISTS $SIDE; "
  $_SQL= $_SQL+"Create View IF NOT EXISTS $SIDE as Select * "
  # Sorting the content of the view is imporant because we want the progression of tiles within
  # a band to start at the reference longitude and go out from there:
  if $SIDE="E"
    $WhichWay="ASC"
    $_SQL= $_SQL+"from GeotileCaches Where NrLongitude >= $RefLongitude and NrLongitude <= $BB_E; "
  else
    $WhichWay="DESC"
    $_SQL= $_SQL+"from GeotileCaches Where NrLongitude <= $RefLongitude and NrLongitude >= $BB_W; "
  Endif
  $SQLresstr=sqlite("sql",$_SQL)

  # Note that on this side of the bounding box we may not have data all
  # the way to the northern and southern ends. So let's make the 
  # rectangle to tile smaller if that is the case.
  $_SQL= "Select max(NrLatitude) from $SIDE"
  $MaxLat=val(sqlite("sql",$_SQL))
  if $BB_N<$MaxLat
   $MaxLat=$BB_N
  endif
  $_SQL= "Select min(NrLatitude) from $SIDE"
  $MinLat=val(sqlite("sql",$_SQL))
  if $BB_S>$MinLat
   $MinLat=$BB_S
  endif

  # Now calculate the widths of the bands:
  $DeltaOnThisSide=($MaxLat-$MinLat)/$BandNumber

  # Let's crank through the various bands and identify tiles that cover each
  # note that there will be east-west gaps between the times, but not between the bands
  $iBand=1
  $BandBot=$MinLat
  $BandTop=$BandBot+$DeltaOnThisSide
  While $iBand<=$BandNumber
    # Create a new SQL view for just the data in this band
    $_SQL= "Drop View IF EXISTS EWBand; "
    $_SQL= $_SQL+"Create View IF NOT EXISTS EWBand as "
    $_SQL= $_SQL+"Select * from $SIDE "
    $_SQL= $_SQL+"Where NrLatitude>=$BandBot And NrLatitude<=$BandTop "
    $_SQL= $_SQL+"Order by NrLongitude $WhichWay; "
    $_SQL= $_SQL+"Select count(*) from EWBand;" 
    $SQLresstr=sqlite("sql",$_SQL)
    # We are not going to count down and as each tile is selected, those GCcodes are stored
    # the remaining ones will then be processed, until none remain. So we need to know 
    # how many remain at any point:
    $Remaining=val($SQLresstr)
    $Limit=$GT_MagicNumber
    $Offset=0
    $CurrentCount=0

    # the following is set up to set up at most this many
    #$GT_MaxNrTilesPerBand=9
    # tiles per band. This is an arbitrary decision to avoid nearly infinite loops

    While ($Remaining > 0) # and ($CurrentCount <= $GT_MaxNrTilesPerBand)
      $CurrentCount = $CurrentCount+1
      ShowStatus msg="$CurrentCount: Processing Tile $CurrentCount in band $iBand$SIDE"

      # subset a region within the current band using the most nr caches the user wants
      $_SQL= "Drop View If Exists Current; Create View Current as "
      $_SQL= $_SQL+"Select * from EWBand Limit $Limit Offset $Offset "
      $SQLresstr=sqlite("sql",$_SQL)

      # The method here is to first try to do things as the user wants
      # but this can result in exceding the absolute (hard) maximum 
      # so we need to modify the tile when that happens
      # Count the number of caches in Current
      $_SQL= "Select count(*) from Current "
      $SQLresstr=sqlite("sql",$_SQL)
      $CacheCount=val($SQLresstr)

      # Count the number of additional waypoints in this set
      $_SQL= "Select code from Current "
      $_SQL= "Select count(*) FROM Waypoints where cParent in ($_SQL)"
      $AddntCount=val(sqlite("sql",$_SQL))
      IF ($Remaining-$CacheCount)<(0.1*$GT_MagicNumber)
        # if there are less than 10% of the desired number per tile remaining for the next tile
        # then go ahead and try to consolidate it into the current tile.
        $_SQL= "Drop View If Exists Current; Create View Current as "
        $_SQL= $_SQL+"Select * from EWBand Limit $GT_MaximumNumber Offset $Offset "
        $SQLresstr=sqlite("sql",$_SQL)
	# Count the numer of caches
	$_SQL= "Select count(*) from Current "
	$SQLresstr=sqlite("sql",$_SQL)
	$CacheCount=val($SQLresstr)

        $_SQL= "Select code from Current "
        $_SQL= "Select count(*) FROM WayAll where cParent in ($_SQL)"
        $AddntCount=val(sqlite("sql",$_SQL))
        $TotalCurrent=$CacheCount+$AddntCount
      endif

      IF $TotalCurrent>$GT_MaximumNumber  # if so then recalculate as follows
	# reduce the $Limit to be so that it WILL work for sure
	# and recalculate the region
	$Limit=$Limit-($TotalCurrent-$GT_MaximumNumber)
	$_SQL= "Drop View IF EXISTS Current; CREATE VIEW Current AS "
	$_SQL= $_SQL+"SELECT * FROM EWBand LIMIT $Limit OFFSET $Offset "
	$SQLresstr=sqlite("sql",$_SQL)
	# Count the numer of caches
	$_SQL= "Select count(*) from Current "
	$SQLresstr=sqlite("sql",$_SQL)
	$CacheCount=val($SQLresstr)
	# Count the number of additional waypoints in this set
	$_SQL= "Select code from Current "
	$_SQL= "Select count(*) FROM WayAll where cParent in ($_SQL)"
	$AddntCount=val(sqlite("sql",$_SQL))
	$TotalCurrent=$CacheCount+$AddntCount  # so this should be smaller than $GT_MaximumNumber
	# Current view now holds the caches in this set
      Endif

      # Get the list of codes of the current view and store it for later use in a LIST
      $_SQL= "Select code from Current "
      $SQLresstr=sqlite("sql",$_SQL)

      $_SQL= "Select min(NrLongitude) from Current "
      $TmpLonMin=sqlite("sql",$_SQL)
      $_SQL= "Select max(NrLongitude) from Current "
      $TmpLonMax=sqlite("sql",$_SQL)
      $RegionName="$iBand$SIDE$CurrentCount"
      $SQLfields="TileName, CacheCount, ChildCount, MinLat, MaxLat, MinLon, MaxLon"
      $_SQL=       "INSERT INTO Geotiles ($SQLfields) "
      $_SQL= $_SQL+"VALUES ('$RegionName', $CacheCount,$AddntCount,$BandBot, $BandTop, $TmpLonMin,$TmpLonMax );"
      $SQLresult=sqlite("sql",$_SQL,"")
      $Remaining=$Remaining-$CacheCount
      $Offset=$Offset+$Cachecount
      $Limit=$GT_MagicNumber
    endwhile
    $iBand=$iBand+1
    $BandBot=$BandTop
    $BandTop=$BandBot+$DeltaOnThisSide
  Endwhile
  # Time for a little clean-up
  $_SQL= "Drop View IF EXISTS $SIDE; Drop View IF EXISTS EWBand; Drop View IF EXISTS Current;"
  $SQLresstr=sqlite("sql",$_SQL)
Endsub

beginsub Name=Sanitize
  # sanitize string in $SaniString
  $SaniString=Replace("&",    "&amp;", $SaniString)         # deal with cachersnames with ampersands
  $SaniString=Replace("&amp;amp;",    "&amp;", $SaniString) # switch all oversantized amp tags back
  $SaniString=Replace("'",    "&apos;",$SaniString)
  $SaniString=Replace($_Quote,"&quot;",$SaniString)
  $SaniString=Replace("<",    "&lt;",  $SaniString)
  $SaniString=Replace(">",    "&gt;",  $SaniString)
endsub

<data> VarName=$DeLormeGPX_Header
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<gpx version="1.1"
 creator="DeLorme Earthmate PN-Series GPS - http://www.delorme.com"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns="http://www.topografix.com/GPX/1/1"
 xmlns:delorme="http://www.delorme.com/schema/gpx_extension"
 xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd
 http://www.delorme.com/schema/gpx_extension http://www.delorme.com/schema/gpx_extension/DeLormeGPXSchema1_1.xsd">
<enddata>

<data> Varname=$TopoDrawLayerInstruction
A Draw file was created for you. Here are instructions on how to use
DeLorme Topo to create a map of the tiles in the PN30/40 GPSr:

1. Open Topo 
2. Create new project
3. Draw a set of lines to get the line color and style to your 
liking. Draw a polygon and set the polygon colors to "Blended" 
yellow (or other very light color). Now delete whatever you drew; 
this will leave the line style setting as you need it. Try to 
pick a color that will work either with day or night setting on 
the GPSr.
4. Click Draw, file button and delete anything that might be there; 
now save this empty project so you don't have to go through all 
this set up the next time.
5. Click on "Handheld Export"; then click the Select/Edit button
6. Click on the Options button in the Handheld Export pane;
Set the checkboxes so only the Drawlayer is selected (be sure 
to scroll down to unselect everything else). For the Zoom Range 
of the Drawlayer select 9 to 13
7. In the edit box under "Save your Map" type in some text 
(e.g. Geotile9-13 Dec27).  Now click Save button.
8. Repeat to create the same map for zoomed-out viewing; use 
zoom ranges 4-8 or 5 to 8 (whichever it allows).
9. Attach GPSr to the computer, turn it on and use the Exchange 
feature to move these maps to the SD card in the GPSr

While the GPSr is attached, you might as well also put it in 
removable drive mode and let the macro write the files directly 
to the gpx folder on the SD card in the GPSr.
<enddata>

Beginsub name=Visualization
  if $DrawLayerCreate
    $_SQL=    "Select 'BEGIN Polygon', MinLat || ',' || MinLon, "
    $_SQL= $_SQL+ "MinLat || ',' || MaxLon, "
    $_SQL= $_SQL+ "MaxLat || ',' || MaxLon, "
    $_SQL= $_SQL+ "MaxLat || ',' || MinLon, "
    $_SQL= $_SQL+ "MinLat || ',' || MinLon || ',' || TileName, 'END' "
    $_SQL= $_SQL+ "FROM Geotiles ;"
    $SQLresult=sqlite("sql",$_SQL,"")
    $DeLormeDrawCode=Replace(";",$_NewLine,$SQLresult)
    IF $DeLormeDraw_folder=""
	$DeLormeDraw_folder=$DeLormeGPX_Folder
    endif
    # the KML output is ready to be saved and displayed
    $FileOut=$DeLormeDraw_folder + "\$SetNameEdit.txt"
    $TMPstr=Putfile($FileOut,$DeLormeDrawCode)
#    FILEOPEN File=$FileOut
    $PauseFormMemo=$TopoDrawLayerInstruction
    gosub name=Pauseform
  endif

  if $GoogleEarthCheckbox
    $KMLStr = addstr(2,"clear")
    $TMPkml=replace("[KMLRUN]",$SetNameEdit,$KMLpolygonsHead)
    $KMLStr = addstr(2,"add",$TMPkml)
    # Process every row in the Geotiles table
    # Now many tiles are there
    $_SQL= "Select count(*) from Geotiles;" 
    $TotalNrTiles=val(sqlite("sql",$_SQL))
    $RowNr=1
    While $RowNr<=$TotalNrTiles
      $_SQL="Select  Tilename "
      $_SQL= $_SQL+ "FROM Geotiles WHERE ROWID=$RowNr ;"
      $SQLresult=sqlite("sql",$_SQL,"")
      $TMPkml=replace("[TILENAME]",$SQLresult,$KMLtilePrefix)     
      # generate kml coordinates for each tile
      $_SQL=    "Select  MinLon || ',' || MinLat || ',0.00 '"
      $_SQL= $_SQL+ "|| MinLon || ',' || MaxLat || ',0.00 '"
      $_SQL= $_SQL+ "|| MaxLon || ',' || MaxLat || ',0.00 '"
      $_SQL= $_SQL+ "|| MaxLon || ',' || MinLat || ',0.00 '"
      $_SQL= $_SQL+ "|| MinLon || ',' || MinLat || ',0.00 '"
      $_SQL= $_SQL+ "FROM Geotiles WHERE ROWID=$RowNr ;"
      $SQLresult=sqlite("sql",$_SQL,"")
      $KMLStr =$TMPkml+$SQLresult+$_NewLine+$KMLtileSuffix
      $KMLStr = addstr(2,"add",$KMLStr)
      $RowNr=$RowNr+1
    endwhile
    $KMLStr = addstr(2,"add",$KMLpolygonsFoot)
    $KMLStr = addstr(2,"get")
    IF $KMLfolder=""
	$KMLFolder=$DeLormeDraw_Folder
    endif
    # the KML output is ready to be saved and displayed
    $FileOut=$KMLFolder + "\$SetNameEdit.kml"
    $TMPstr=Putfile($FileOut,$KMLStr)
    FILEOPEN File=$FileOut
  endif

endsub

<data> VarName=$KMLpolygonsHead
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">
<Document>
  <name>GeoTile Output</name>
  <StyleMap id="msn_ylw-pushpin">
	<Pair><key>normal</key><styleUrl>#sn_ylw-pushpin</styleUrl></Pair>
	<Pair><key>highlight</key><styleUrl>#sh_ylw-pushpin</styleUrl></Pair>
  </StyleMap>
  <Style id="sh_ylw-pushpin">
	<IconStyle><scale>1.2</scale></IconStyle>
	<LineStyle><color>ff00ffff</color><width>3</width></LineStyle>
	<PolyStyle><color>997fffff</color></PolyStyle>
  </Style>
  <Style id="sn_ylw-pushpin">
	<LineStyle><color>ff00ffff</color><width>3</width></LineStyle>
	<PolyStyle><color>997fffff</color></PolyStyle>
  </Style>
  <Folder>
	<name>[KMLRUN]</name>
	<open>1</open>
	<Folder>
		<name>Tiles</name>
		<open>1</open>
<enddata>


<data> VarName=$KMLtilePrefix
		<Placemark>
			<name>[TILENAME]</name>
			<description>Band-Side-Number:[TILENAME]</description>
			<styleUrl>#msn_ylw-pushpin</styleUrl>
			<Polygon>
				<tessellate>1</tessellate>
				<outerBoundaryIs>
					<LinearRing><coordinates>
<enddata>


<data> VarName=$KMLtileSuffix
					</coordinates></LinearRing>
				</outerBoundaryIs>
			</Polygon>
		</Placemark>
<enddata>

<data> VarName=$KMLpolygonsFoot
	</Folder>
  </Folder>
</Document>
</kml>

<enddata>

<data> VarName=$DeLormeGPX_Footer

</gpx>
<enddata>


########################################### PAUSE FORM #############################
# The PauseForm subroutine will return: 
#  $PauseForm_YesNo is boolean: true: Yes and Continue all other buttons: False
#  $PauseForm_Response = Uppercase button text space removed (YES, NO, CONTINUE,...)
#  $FormExit = name of control (button) that caused the form to exit
Beginsub Name=PauseForm
 $PauseForm_YesNo = true
 $PauseForm_Response=""        #this is the response variable
 While $PauseForm_YesNo # Infinite loop to redisplay form as required
 If $PauseFormMemo=""
  $PauseFormMemo=" no text "
  $PauseForm = EditForm($PauseForm,"PauseForm","Height","100")
 ELSE
  $PauseForm = EditForm($PauseForm,"PauseForm","Height","363")
 Endif
  $FormExit = form($PauseForm,"")
  BeginCase
    Case $FormExit = "PauseFormYesButton"
	$PauseForm_YesNo = true
	$PauseForm_Response = "YES"
	Break
    Case $FormExit = "PauseFormNoButton"
	$PauseForm_YesNo = false
	$PauseForm_Response = "NO"
	Break
    Case $FormExit = "DelayExit"
# Un-comment the next line to force a delayed exit message requiring a user button click
#	MsgOk msg="PauseForm exit via Delay"
	Break
    Case $FormExit = "SystemExit"
      #     MsgOk msg="Form exit via red X button on form"
	$PauseForm_YesNo = false
	break
    Case $FormExit = "PauseFormStopMacroButton"
      # user want to stop the macro completely
	$PauseForm_YesNo = false
	$PauseForm_Response = "STOPMACRO"
	Return
    Case $FormExit = "PauseFormContinueButton"
      # user want to simply move on without stopping the macro
	$PauseForm_YesNo = true
	$PauseForm_Response = "CONTINUE"
	if $_CtrlKey 
	    # If user clicks CONTINUE while holding down the control key then this code will run
	    # this example just loads the code for the form 
	    $PauseFormMemo="<Data> VarName=$"+"PauseForm $_NewLine" +$PauseForm + $_NewLine + "<enddata>"
	    Clip data="$TmpStr"
	else
	    Break
	endif
  EndCase
 EndWhile
endsub

<Data> VarName=$PauseForm
#********************************************************************
# Form generated by GSAK form designer on Mon 14-Dec-2009 09:53:10
#********************************************************************

Name = PauseForm
  Type = Form
  Caption = seconds of PAUSE for this GSAK macro (Geotile.gsk by Hynr)
  Delay = 86400
  Height = 363
  Width = 584

Name = PauseFormPromptText
  Type = Label
  Font = Arial
  Height = 19
  Left = 8
  Size = 12
  Style = bold
  Top = 8
  Width = 519
  Caption = Click one of these buttons to indicate how you would like to proceed

Name = PauseFormMemo
  Type = Memo
  Font = Courier New
  Height = 258
  Left = 10
  Scrollbars = Both
  Size = 10
  Top = 64
  Width = 559
  Taborder = 10

Name = PauseFormYesButton
  Type = Button
  Height = 33
  Left = 8
  Top = 32
  Width = 121
  Taborder = 12
  Caption = YES

Name = PauseFormNoButton
  Type = Button
  Height = 33
  Left = 136
  Top = 32
  Width = 113
  Taborder = 13
  Caption = NO

Name = PauseFormStopMacroButton
  Type = Button
  Height = 33
  Left = 440
  Top = 32
  Width = 129
  Taborder = 5
  Caption = Stop Macro

Name = PauseFormContinueButton
  Type = Button
  Height = 33
  Left = 256
  Top = 32
  Width = 177
  Taborder = 4
  Caption = Continue

<enddata>

Beginsub Name=BMPDrawDisplayGrid
# all the records in the current display grid are drawn as small square dots into 
# the front layer 
  $_SQL= "Select count(*) From GeotileCaches"
  $TotalCacheCount=val(sqlite("sql",$_SQL))
  $RowNr=1
  While $RowNr<=$TotalCacheCount
    $_SQL= "Select code, NrLatitude, NrLongitude FROM GeotileCaches WHERE ROWID=$RowNr ;"
    $TmpStr=sqlite("sql",$_SQL,"")
    $BMP_LabelText=extract($TmpStr,";",1)
    $BMP_lat=val(extract($TmpStr,";",2))
    $BMP_lon=val(extract($TmpStr,";",3))
    Gosub Name=BMPDrawPoint3
    Gosub Name=BMP_CreateLabel
    $RowNr=$RowNr+1
  EndWhile
endsub

Beginsub Name=BMPinitialization
# This sets values for all the graphics variable so they can
# be used in the rest of the subroutines
# to be able to draw we neet to map the 600 pixels side to side to longitudes
# and 600 pixels top to bottom to latitudes
# these are should be the extremes 
  $BMP_NrPixels=600  
  $BMP_PixMax=620  #This is locked in by the BMP header; do not change this
  if $BMP_NrPixels=$BMP_PixMax
    $BMP_NrPixels=$BMP_PixMax-4 #we cannot tolerate it if user has modifed this incorrectly
  endif
  $BMP_bias=Int(($BMP_PixMax-$BMP_NrPixels)/2)

# now all the colors in the pallette (even though 256 colors are in the pallette
# there really are only 16 colors defined; To increase this require modifying the 
# BMPheader)
  $BMP_ColorNrWhite=15
  $BMP_ColorNrCyan=14
  $BMP_ColorNrLightViolet=13
  $BMP_ColorNrLightBlue=12
  $BMP_ColorNrYellow=11
  $BMP_ColorNrLightGreen=10
  $BMP_ColorNrOrange=9
  $BMP_ColorNrGrey=8
  $BMP_ColorNrDarkGrey=7
  $BMP_ColorNrDarkCyan=6
  $BMP_ColorNrViolet=5
  $BMP_ColorNrBlue=4
  $BMP_ColorNrDarkYellow=3
  $BMP_ColorNrGreen=2
  $BMP_ColorNrRed=1
  $BMP_ColorNrBlack=0

  # various specific-purpose color variables
  # default color
  $BMP_ColorNr=$BMP_ColorNrCyan

  $BMP_ColorTransparent=0
  $BMP_ColorBackground=$BMP_ColorNrGrey

  $BMP_ColorGridLine=$BMP_ColorNrBlack
  $BMP_ColorSymbol=$BMP_ColorNrViolet
  $BMP_ColorLine=$BMP_ColorNrOrange
  $BMP_LineThick=false

# build 2 backgrounds: front layer transparent, 
# rear layer with gridlines subject to the following
  $BMP_ShowGridLines=False
  $BMP_icnt=1
  $BMP_TmpStr=""
  $BMP_TMPStrBack=""
  While $BMP_icnt<=$BMP_PixMax
   $BMP_TMPstr=$BMP_TMPstr+chr($BMP_ColorTransparent)
   if $BMP_ShowGridLines and (frac($BMP_iCnt/20)=0)
     $BMP_TMPstrBack=$BMP_TMPstrBack+chr($BMP_ColorGridLine)
   else 
     $BMP_TMPstrBack=$BMP_TMPstrBack+chr($BMP_ColorBackground)
   endif
   $BMP_icnt=$BMP_icnt+1
  endwhile

#initialize the graphic area so every pixel is the background color
# in case array number ever needs to be changed due to conflicts, make it variable:
  $BMP_ArrayFront =11
  $BMP_ArrayBack  =12
  $BMP_ArrayFront2=21
  $BMP_ArrayBack2 =22
# set up the data structures for the BMP front and back layers
  Array($BMP_ArrayFront,0)="$BMP_PixMax"
  Array($BMP_ArrayFront,-1)=$BMP_TMPstr
  Array($BMP_ArrayBack,0)="$BMP_PixMax"
  Array($BMP_ArrayBack,-1)=$BMP_TMPstrBack
# we need the following so we can reset the canvas without recalculating all this
  Array($BMP_ArrayFront2,0)="$BMP_PixMax"
  Array($BMP_ArrayFront2,-1)=$BMP_TMPstr
  Array($BMP_ArrayBack2,0)="$BMP_PixMax"
  Array($BMP_ArrayBack2,-1)=$BMP_TMPstrBack

#horizontal grid lines every 20 rows on the backdrop but only
  if $BMP_ShowGridLines
    $BMP_GridLine=Replace(chr($BMP_ColorTransparent),chr($BMP_ColorGridLine),$BMP_TMPstr)
    $BMP_icnt=20
    While $BMP_icnt<=$BMP_PixMax
     Array($BMP_ArrayBack,$BMP_icnt)=$BMP_GridLine
     Array($BMP_ArrayBack2,$BMP_icnt)=$BMP_GridLine
     $BMP_icnt=$BMP_icnt+20
    endwhile
  endif

# activate the selections to see back and front; set up labeling
  $BMP_DisplayFrontCheck=true
  $BMP_DisplayBackCheck=true

  $BMP_LabelCount=1000  # start at 1000 for formatting and sorting convenience
  $BMP_Labels=""
  $BMP_DisplayLabels=false

  $BMP_BBrectLabel=""

  $BMPkeeprunning=true
endsub

Beginsub Name=BMPSetRelative 
# Build the coordinate system and how it is related to pixels in the window.
# Determine which of the two extents is longer
  $BMP_DeltaLat = $BMP_BB_N - $BMP_BB_S
  $BMP_DeltaLon = $BMP_BB_E - $BMP_BB_W
# Whichever is bigger wins because we want to keep the graph square
  if $BMP_DeltaLat> $BMP_DeltaLon
    $BMP_DeltaLatLon=$BMP_DeltaLat
    # safety: if the increment is very small, then don't accept that because it will cause problems
    if $BMP_DeltaLatLon<0.001
     $BMP_DeltaLatLon=0.001
    endif
    # The resulting extremes (shift the cluster laterally into the middle)
    $BMP_MinLatDraw=$BMP_BB_S
    $BMP_MinLonDraw=$BMP_BB_W - ($BMP_DeltaLatLon-$BMP_DeltaLon)/2
  Else 
    $BMP_DeltaLatLon=$BMP_DeltaLon
    # safety: if the increment is very small, then don't accept that because it will cause problems
     if $BMP_DeltaLatLon<0.001
      $BMP_DeltaLatLon=0.001
     endif
    # The resulting extremes (shift the cluster vertically into the middle)
    $BMP_MinLatDraw=$BMP_BB_S - ($BMP_DeltaLatLon-$BMP_DeltaLat)/2
    $BMP_MinLonDraw=$BMP_BB_W 
  endif
  $BMP_MaxLatDraw=$BMP_MinLatDraw+$BMP_DeltaLatLon
  $BMP_MaxLonDraw=$BMP_MinLonDraw+$BMP_DeltaLatLon
  $BMP_PixDelta=$BMP_DeltaLatLon/$BMP_NrPixels
  # label the graph
  $BMPlabelNW="$BMP_MaxLatDraw,$BMP_MinLonDraw"
  $Mainform=Editform($Mainform,"BMPlabelNW","Caption",$BMPlabelNW)
  $BMPlabelNE="$BMP_MaxLatDraw,$BMP_MaxLonDraw"
  $Mainform=Editform($Mainform,"BMPlabelNE","Caption",$BMPlabelNE)
  $BMPlabelSW="$BMP_MinLatDraw,$BMP_MinLonDraw"
  $Mainform=Editform($Mainform,"BMPlabelSW","Caption",$BMPlabelSW)
  $BMPlabelSE="$BMP_MinLatDraw,$BMP_MaxLonDraw"
  $Mainform=Editform($Mainform,"BMPlabelSE","Caption",$BMPlabelSE)
endsub 

Beginsub Name=BMPDrawPoint3
# draw 3-pixel by 3-pixel point for current lat and lon
# obtain pixel locations of current point
  Gosub Name=BMPDrawPointLoc
# stay within the graphic image 
  if $BMP_Y<=2 or $BMP_Y>=$BMP_PixMax-2 or $BMP_x<=2 or $BMP_x>=$BMP_PixMax-2
   # Cropping issues would be addressed here
  else
   $BMP_DrawSymb=Chr($BMP_ColorNr)+Chr($BMP_ColorNr)+Chr($BMP_ColorNr)
   $BMP_TMPstr=Array($BMP_Array,$BMP_y-1)
   Array($BMP_Array,$BMP_y-1)=substr($BMP_TMPstr,1,$BMP_x-2) + $BMP_DrawSymb + substr($BMP_TMPstr,$BMP_x+2,$BMP_PixMax)
   $BMP_TMPstr=Array($BMP_Array,$BMP_y)
   Array($BMP_Array,$BMP_y)=substr($BMP_TMPstr,1,$BMP_x-2) + $BMP_DrawSymb + substr($BMP_TMPstr,$BMP_x+2,$BMP_PixMax)
   $BMP_TMPstr=Array($BMP_Array,$BMP_y+1)
   Array($BMP_Array,$BMP_y+1)=substr($BMP_TMPstr,1,$BMP_x-2) + $BMP_DrawSymb + substr($BMP_TMPstr,$BMP_x+2,$BMP_PixMax)
  endif
endsub

Beginsub Name=BMPDrawPoint1
# draw 1-pixel by 1-pixel point for current lat and lon (BMP_lat and BMP_lon)
# obtain pixel locations of current point
  Gosub Name=BMPDrawPointLoc
  if $BMP_Y<=1 or $BMP_Y>=$BMP_PixMax-1 or $BMP_x<=1 or $BMP_x>=$BMP_PixMax-1
   # code to be added later?: to deal with cropped stuff if/when that is needed
  else
   $BMP_DrawSymb=Chr($BMP_ColorNr)
   $BMP_TMPstr=Array($BMP_Array,$BMP_y)
   Array($BMP_Array,$BMP_y)=substr($BMP_TMPstr,1,$BMP_x-1) + $BMP_DrawSymb + substr($BMP_TMPstr,$BMP_x+1,$BMP_PixMax)
  endif
endsub

Beginsub Name=BMPDrawPointLoc
# draw point at ($BMP_Lat, $BMP_Lon) for current lat and long 
# $bias shifts the image up and right to avoid out-of-bounds 
  $BMP_y=$BMP_bias+round(($BMP_lat -$BMP_MinLatDraw)/$BMP_PixDelta,0)
  $BMP_x=$BMP_bias+round(($BMP_lon -$BMP_MinLonDraw)/$BMP_PixDelta,0)
endsub


Beginsub Name=BMPDrawLine
# Connect two coordinates ($BMP_Lat1, $BMP_Lon1) and ($BMP_Lat2, $BMP_Lon2)
# with 1-pixel thick line of color $BMP_ColorLine
# if $BMP_LineThick is true then the line will be 3-pixels thick
  $BMP_lat=$BMP_lat2
  $BMP_lon=$BMP_lon2
  gosub Name=BMPDrawPoint1
  #save pixel info
  $xold=$BMP_x
  $yold=$BMP_y
  $BMP_lat=$BMP_lat1
  $BMP_lon=$BMP_lon1
  gosub Name=BMPDrawPoint1
  $BMP_pixdifx=abs($xold-$BMP_x)
  $BMP_pixdify=abs($yold-$BMP_y)
# use whichever is the longest distance to identify which pixels need calculating
  if $BMP_pixdifx<$BMP_pixdify
    $BMP_pixdifx=$BMP_pixdify
  endif
  If $BMP_pixdifx<1  #Trap situations where the line has no length - make it one pixel long
    $BMP_pixdifx=1
    # No need to draw anything else since that pixel is already drawn
  else
    $BMP_deltaLat=($BMP_lat2-$BMP_lat1)/$BMP_pixdifx
    $BMP_deltaLon=($BMP_lon2-$BMP_lon1)/$BMP_pixdifx
    $BMP_icnt=1
    while $BMP_icnt < $BMP_pixdifx
      $BMP_lat=$BMP_lat+$BMP_deltaLat
      $BMP_lon=$BMP_lon+$BMP_deltaLon
      if $BMP_LineThick
        gosub Name=BMPDrawPoint3
      Else
        gosub Name=BMPDrawPoint1
      endif
      $BMP_icnt=$BMP_icnt+1
    endwhile
   endif
endsub

Beginsub Name=BMPDrawBBRectangle
# Draw any bounding box rectangle using the following extremes $BMP_BBrectN, $BMP_BBrectS, $BMP_BBrectW, $BMP_BBrectE
# If a centered label is to be used then place that text into $BMP_BBrectLabel
  $BMP_lat1=$BMP_BBrectN
  $BMP_lon1=$BMP_BBrectE
  $BMP_lat2=$BMP_BBrectN
  $BMP_lon2=$BMP_BBrectW
  gosub Name=BMPDrawline
  IF $BMP_BBrectFill
    #just do the fill and include the edges
    $BMP_ArrayRow=$BMP_y
    $BMP_LinePos1=$BMP_x
    $BMP_LinePos2=$BMP_LinePos1 + $BMP_pixdifx
    $BMP_Lat=$BMP_BBrectS
    $BMP_Lon=$BMP_BBrectW
    gosub Name=BMPDrawPointLoc
    $BMP_TMPstr=Array($BMP_Array,$BMP_ArrayRow)
    $BMP_Segment=substr($BMP_TMPstr,$BMP_LinePos1,$BMP_pixdifx)
    While $BMP_ArrayRow>$BMP_y
     if $BMP_ArrayRow>0 and $BMP_ArrayRow<$BMP_PixMax
       $BMP_TMPstr=Array($BMP_Array,$BMP_ArrayRow)
       Array($BMP_Array,$BMP_ArrayRow)=substr($BMP_TMPstr,1,$BMP_LinePos1-1) + $BMP_Segment + substr($BMP_TMPstr,$BMP_LinePos2,$BMP_PixMax)
     endif
     $BMP_ArrayRow = $BMP_ArrayRow - 1
    endwhile
  Else
    # no fill, so just draw the edges
    $BMP_lat1=$BMP_BBrectS
    $BMP_lon1=$BMP_BBrectW
    gosub Name=BMPDrawline
    $BMP_lat2=$BMP_BBrectS
    $BMP_lon2=$BMP_BBrectE
    gosub Name=BMPDrawline
    $BMP_lat1=$BMP_BBrectN
    $BMP_lon1=$BMP_BBrectE
    gosub Name=BMPDrawline
  Endif
  if not($BMP_BBrectLabel="")
    $BMP_Lat=($BMP_BBrectN+$BMP_BBrectS)/2
    $BMP_Lon=($BMP_BBrectW+$BMP_BBrectE)/2
    gosub Name=BMPDrawPointLoc
    $BMP_LabelText=$BMP_BBrectLabel
    Gosub Name=BMP_CreateLabel
    $BMP_BBrectLabel=""
  endif
endsub

Beginsub Name=BMP_CreateLabel
# Labels are placed between the front and back layer as labels on the form
# coordinates are with respect to the BMPgroup container, 
# All labels created this way are simply appended to $BMP_labels
# each is at the current $BMP_x,$BMP_y pixel location; text is in $BMP_LabelText
#(we probably should trap linefeeds here)
# Label counter starts at 1000
  $BMP_LabelCount=$BMP_LabelCount+1
  $BMP_TmpStr="Name = BMPLabel$BMP_LabelCount"
  $BMP_TmpStr= $BMP_TmpStr+"$_NewLine  Type = Label $_NewLine  Container = BMPgroup$_NewLine  Height = 13"
  $BMP_TMPint=$BMP_PixMax-$BMP_y+1
  if $BMP_TMPint<10
     $BMP_TMPint=10
  endif
  $BMP_TmpStr= $BMP_TmpStr + $_NewLine +"  Caption = $BMP_LabelText"
  $BMP_TmpStr= $BMP_TmpStr + $_NewLine +"  Top =$BMP_TMPint"+$_NewLine 
  $BMP_TMPint=$BMP_x+30
  if $BMP_TMPint<1
     $BMP_TMPint=1
  endif
  $BMP_TmpStr= $BMP_TmpStr+"  Left =$BMP_TMPint"+$_NewLine+$_NewLine
  $BMP_labels=$BMP_labels+$BMP_TmpStr
endsub

Beginsub Name=DrawBBandReferenceLon
# set the extremes using the variables that BMPDrawBBRectangle expects
  $BMP_BBrectN=$BMP_BB_N 
  $BMP_BBrectS=$BMP_BB_S
  $BMP_BBrectW=$BMP_BB_W
  $BMP_BBrectE=$BMP_BB_E 
# chose to fill in this rectangle (or not); normally this is set to false
  $BMP_BBrectFill=false
  $BMP_ColorNr=$BMP_ColorNrOrange
  Gosub Name=BMPDrawBBRectangle
# Draw the reference line
  $BMP_LineThick=True
  $BMP_Lat1=$BMP_BB_N     # draw to 10% beyond top edge of BBox
  $BMP_Lon1=val($Referencelon)  # use the number that is on the form for this
  $BMP_Lat2=$BMP_BB_S  # draw to bottom edge of BBox and a bit further
  $BMP_Lon2=$BMP_Lon1
  Gosub Name=BMPDrawLine
Endsub

Beginsub Name=StatusDisplay
# assumes the message to be displayed is in $StatusMessage
# advantage of this approach is that it automatically includes code pointer in the error log
  ShowStatus msg=$StatusMessage width=600 
endsub

<data> Varname=$BMP620HeadMime
Qk1a3wUAAAAAADYEAAAoAAAAawIAAGsCAAABAAgAAAAAACTbBQAAAAAACgAAAAABAAAAAQAAAAAAAAAA
gAAAgAAAAICAAIAAAACAAIAAgIAAAICAgADAwMAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAA
AAAAAIAAAIAAAACAgACAAAAAgACAAICAAACAgIAAwMDAAAAA/wAA/wAAAP//AP8AAAD/AP8A//8AAP//
/wAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//
AAD///8AAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAICAgADAwMAAAAD/AAD/AAAA//8A/wAAAP8A
/wD//wAA////AAAAAAAAAIAAAIAAAACAgACAAAAAgACAAICAAACAgIAAwMDAAAAA/wAA/wAAAP//AP8A
AAD/AP8A//8AAP///wAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD/
/wD/AAAA/wD/AP//AAD///8AAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAICAgADAwMAAAAD/AAD/
AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAIAAAIAAAACAgACAAAAAgACAAICAAACAgIAAwMDAAAAA
/wAA/wAAAP//AP8AAAD/AP8A//8AAP///wAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDA
wAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAICA
gADAwMAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAIAAAIAAAACAgACAAAAAgACAAICA
AACAgIAAwMDAAAAA/wAA/wAAAP//AP8AAAD/AP8A//8AAP///wAAAAAAAACAAACAAAAAgIAAgAAAAIAA
gACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAgAAAgAAAAICAAIAA
AACAAIAAgIAAAICAgADAwMAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAIAAAIAAAACA
gACAAAAAgACAAICAAACAgIAAwMDAAAAA/wAA/wAAAP//AP8AAAD/AP8A//8AAP///wAAAAAAAACAAACA
AAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAA
gAAAgAAAAICAAIAAAACAAIAAgIAAAICAgADAwMAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AA==
<enddata>


<Data> VarName=$Mainform 
#********************************************************************
# Form generated by GSAK form designer on Sat 26-Dec-2009 23:44:44
#********************************************************************

Name = MainForm
  Type = Form
  Caption = Geotile.gsk by Hynr
  Height = 787
  Width = 837

Name = MainGroup
  Type = Groupbox
  Caption = GeoTile
  Height = 641
  Left = -8
  Top = 0
  Width = 841
  Taborder = 0

Name = OptionsGroup
  Type = Groupbox
  Caption = Export Options
  Height = 113
  Left = 8
  Top = 528
  Visible = Yes
  Width = 145
  Taborder = 1

Name = TileGroup
  Type = Groupbox
  Caption = Tile specifications
  Container = MainGroup
  Height = 145
  Left = 16
  Top = 216
  Width = 145
  Taborder = 2

Name = Visualize
  Type = Groupbox
  Caption = Export actions
  Height = 106
  Left = 3
  Top = 635
  Visible = Yes
  Width = 745
  Taborder = 3

Name = BBox
  Type = Groupbox
  Caption = Bounding Box
  Container = MainGroup
  Height = 199
  Left = 16
  Top = 18
  Visible = Yes
  Width = 145
  Taborder = 3

Name = BMPgroup
  Type = Groupbox
  Caption = Visualization of Current Display Grid Data
  Container = MainGroup
  Height = 641
  Left = 160
  Top = 0
  Width = 673
  Taborder = 4

Name = GraphAreaBack
  Type = Image
  Container = BMPgroup
  File = BMP2FILE.bmp
  Height = 620
  Left = 32
  Resize = Yes
  Source = macro
  Top = 13
  Transparent = Yes
  Width = 620

Name = GraphAreaFront
  Type = Image
  Container = BMPgroup
  File = BMPFILE.bmp
  Height = 620
  Left = 32
  Resize = Yes
  Source = macro
  Top = 13
  Transparent = Yes
  Width = 620

Name = BMPLabelNW
  Type = Label
  Container = BMPgroup
  Height = 13
  Left = 8
  Top = 13
  Width = 140

Name = BMPLabelNE
  Type = Label
  Container = BMPgroup
  Height = 13
  Left = 600
  Top = 13
  Width = 73

Name = BMPLabelSW
  Type = Label
  Container = BMPgroup
  Height = 13
  Left = 16
  Top = 616
  Width = 89

Name = BMPLabelSE
  Type = Label
  Container = BMPgroup
  Height = 13
  Left = 590
  Top = 616
  Width = 81

Name = BMP_DisplayFrontCheck
  Type = Checkbox
  Container = BMPgroup
  Exitonchange = Yes
  Height = 17
  Left = 113
  Top = 621
  Width = 201
  Taborder = 0
  Caption = Display the Caches as dots

Name = BMP_DisplayBackCheck
  Type = Checkbox
  Container = BMPgroup
  Exitonchange = Yes
  Height = 17
  Left = 270
  Top = 621
  Width = 201
  Taborder = 1
  Caption = Display the rectangles

Name = BMP_DisplayLabels
  Type = Checkbox
  Container = BMPgroup
  Exitonchange = Yes
  Height = 17
  Left = 408
  Top = 621
  Width = 169
  Taborder = 2
  Caption = Display text labels in image

Name = BandNumberEdit
  Type = Edit
  Container = MainGroup
  Height = 21
  Left = 64
  Top = 421
  Width = 65
  Taborder = 1

Name = QuitButton
  Type = Button
  Height = 89
  Left = 746
  Top = 655
  Width = 81
  Taborder = 2
  Caption = Exit

Name = Label3
  Type = Label
  Container = OptionsGroup
  Height = 13
  Left = 8
  Top = 24
  Width = 96
  Caption = Maximum Nr of Logs

Name = MaxLogNrEdit
  Type = Edit
  Container = OptionsGroup
  Height = 21
  Left = 110
  Top = 24
  Width = 33
  Taborder = 0

Name = Memo2
  Type = Memo
  Height = 113
  Left = 0
  Readonly = Yes
  Scrollbars = Vertical
  Size = 10
  Top = 640
  Visible = Yes
  Width = 745
  Wrap = Yes
  Taborder = 4

Name = HardMaxEdit
  Type = Edit
  Container = TileGroup
  Height = 21
  Left = 81
  Top = 35
  Width = 35
  Taborder = 0

Name = Label1
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 5
  Top = 31
  Width = 70
  Caption = Hard Maximum

Name = Label2
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 2
  Top = 65
  Width = 66
  Caption = Soft Maximum

Name = SoftMaxEdit
  Type = Edit
  Container = TileGroup
  Height = 21
  Left = 79
  Top = 69
  Width = 34
  Taborder = 1

Name = Label4
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 11
  Top = 45
  Width = 61
  Caption = Incl. Children

Name = Label5
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 8
  Top = 79
  Width = 65
  Caption = nr geocaches

Name = Label8
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 8
  Top = 16
  Width = 89
  Caption = Geocaches per tile

Name = IncludeAddtnl
  Type = Checkbox
  Container = TileGroup
  Height = 17
  Left = 7
  Top = 101
  Width = 118
  Taborder = 2
  Caption = Include Child  Way-

Name = Label14
  Type = Label
  Container = TileGroup
  Height = 13
  Left = 19
  Top = 115
  Width = 98
  Caption = points in calculations

Name = TileButton
  Type = Button
  Container = MainGroup
  Height = 35
  Left = 18
  Top = 448
  Width = 143
  Taborder = 0
  Caption = TILE the DATA

Name = VisualizeButton
  Type = Button
  Container = Visualize
  Height = 46
  Left = 590
  Top = 11
  Width = 147
  Taborder = 0
  Caption = Create these exports

Name = GoogleEarthCheckbox
  Type = Checkbox
  Container = Visualize
  Height = 17
  Left = 12
  Top = 15
  Width = 165
  Taborder = 1
  Caption = Google Earth == put files here:

Name = DrawLayerCreate
  Type = Checkbox
  Container = Visualize
  Height = 17
  Left = 10
  Top = 34
  Width = 153
  Taborder = 2
  Caption = Drawlayer for DeLormeTopo

Name = SetNameEdit
  Type = Edit
  Container = OptionsGroup
  Height = 21
  Left = 26
  Top = 74
  Width = 55
  Taborder = 1

Name = Label6
  Type = Label
  Container = OptionsGroup
  Height = 13
  Left = 8
  Top = 56
  Width = 126
  Caption = Base of filename for Export

Name = TotalCacheCountEdit
  Type = Label
  Container = MainGroup
  Height = 20
  Left = 56
  Size = 12
  Top = 384
  Width = 27
  Caption = 150

Name = Label9
  Type = Label
  Container = MainGroup
  Height = 13
  Left = 18
  Top = 366
  Width = 106
  Caption = Display-grid # Caches:

Name = Label10
  Type = Label
  Container = BBox
  Height = 13
  Left = 16
  Top = 21
  Width = 26
  Caption = North

Name = Label11
  Type = Label
  Container = BBox
  Height = 13
  Left = 16
  Top = 92
  Width = 28
  Caption = South

Name = Label12
  Type = Label
  Container = BBox
  Height = 13
  Left = 4
  Top = 44
  Width = 25
  Caption = West

Name = Label13
  Type = Label
  Container = BBox
  Height = 13
  Left = 77
  Top = 44
  Width = 21
  Caption = East

Name = BB_Nedit
  Type = Edit
  Container = BBox
  Height = 21
  Left = 48
  Top = 16
  Width = 65
  Taborder = 0

Name = BB_Eedit
  Type = Edit
  Container = BBox
  Height = 21
  Left = 72
  Top = 58
  Width = 65
  Taborder = 1

Name = BB_Wedit
  Type = Edit
  Container = BBox
  Height = 21
  Left = 0
  Top = 58
  Width = 65
  Taborder = 2

Name = BB_Sedit
  Type = Edit
  Container = BBox
  Height = 21
  Left = 48
  Top = 88
  Width = 65
  Taborder = 3

Name = BBbutton
  Type = Button
  Container = BBox
  Height = 33
  Left = 10
  Top = 154
  Width = 103
  Taborder = 4
  Caption = Redisplay

Name = KMLFolder
  Type = Folder
  Container = Visualize
  Height = 21
  Left = 176
  Top = 13
  Width = 409
  Taborder = 3

Name = DeLormeDraw_Folder
  Type = Folder
  Container = Visualize
  Height = 21
  Left = 176
  Top = 36
  Width = 409
  Taborder = 4

Name = Label16
  Type = Label
  Container = MainGroup
  Height = 13
  Left = 16
  Top = 405
  Width = 118
  Caption = Desired number of bands

Name = ReferenceLon
  Type = Edit
  Container = BBox
  Height = 21
  Left = 15
  Top = 125
  Width = 89
  Taborder = 5

Name = Label15
  Type = Label
  Container = BBox
  Height = 13
  Left = 7
  Top = 109
  Width = 100
  Caption = Reference Longitude

Name = DeLormeButton
  Type = Button
  Container = Visualize
  Height = 36
  Left = 590
  Top = 59
  Visible = Yes
  Width = 147
  Taborder = 5
  Caption = Create DeLorme-specific gpx

Name = DeLormeGPX_Folder
  Type = Folder
  Container = Visualize
  Height = 21
  Left = 176
  Top = 71
  Width = 410
  Taborder = 6

Name = Label7
  Type = Label
  Container = Visualize
  Height = 13
  Left = 41
  Top = 71
  Width = 131
  Caption = Folder for DeLorme gpx files

<enddata>

Beginsub Name=VariableDeclarations
#*******************************************************
#   Variable declarations for
#   C:\Documents and Settings\Lieth\My Documents\Play\Geo\GSAK\Data\Macros\GeoTile104.gsk
#
#   Generated 12/26/2009 on GSAKVariables.gsk Rev V0.31
#
#*******************************************************


Option Explicit=Yes

Declare Var=$Addnt Type=String
Declare Var=$AddntCount Type=Numeric
Declare Var=$BandBot Type=Numeric
Declare Var=$BandNumber Type=Numeric
Declare Var=$BandNumberEdit Type=String
Declare Var=$BandTop Type=Numeric
Declare Var=$BB_E Type=Numeric
Declare Var=$BB_Eedit Type=String
Declare Var=$BB_N Type=Numeric
Declare Var=$BB_Nedit Type=String
Declare Var=$BB_S Type=Numeric
Declare Var=$BB_Sedit Type=String
Declare Var=$BB_W Type=Numeric
Declare Var=$BB_Wedit Type=String
Declare Var=$bigStr Type=String
Declare Var=$BMP_Array Type=Numeric
Declare Var=$BMP_ArrayBack Type=Numeric
Declare Var=$BMP_ArrayBack2 Type=Numeric
Declare Var=$BMP_ArrayFront Type=Numeric
Declare Var=$BMP_ArrayFront2 Type=Numeric
Declare Var=$BMP_ArrayRow Type=Numeric
Declare Var=$BMP_BB_E Type=Numeric
Declare Var=$BMP_BB_N Type=Numeric
Declare Var=$BMP_BB_S Type=Numeric
Declare Var=$BMP_BB_W Type=Numeric
Declare Var=$BMP_BBrectE Type=Numeric
Declare Var=$BMP_BBrectFill Type=Boolean
Declare Var=$BMP_BBrectLabel Type=String
Declare Var=$BMP_BBrectN Type=Numeric
Declare Var=$BMP_BBrectS Type=Numeric
Declare Var=$BMP_BBrectW Type=Numeric
Declare Var=$BMP_bias Type=Numeric
Declare Var=$BMP_CacheNames Type=String
Declare Var=$BMP_ColorBackground Type=Numeric
Declare Var=$BMP_ColorGridLine Type=Numeric
Declare Var=$BMP_ColorLine Type=Numeric
Declare Var=$BMP_ColorNr Type=Numeric
Declare Var=$BMP_ColorNrBlack Type=Numeric
Declare Var=$BMP_ColorNrBlue Type=Numeric
Declare Var=$BMP_ColorNrCyan Type=Numeric
Declare Var=$BMP_ColorNrDarkCyan Type=Numeric
Declare Var=$BMP_ColorNrDarkGrey Type=Numeric
Declare Var=$BMP_ColorNrDarkYellow Type=Numeric
Declare Var=$BMP_ColorNrGreen Type=Numeric
Declare Var=$BMP_ColorNrGrey Type=Numeric
Declare Var=$BMP_ColorNrLightBlue Type=Numeric
Declare Var=$BMP_ColorNrLightGreen Type=Numeric
Declare Var=$BMP_ColorNrLightViolet Type=Numeric
Declare Var=$BMP_ColorNrOrange Type=Numeric
Declare Var=$BMP_ColorNrRed Type=Numeric
Declare Var=$BMP_ColorNrViolet Type=Numeric
Declare Var=$BMP_ColorNrWhite Type=Numeric
Declare Var=$BMP_ColorNrYellow Type=Numeric
Declare Var=$BMP_ColorSymbol Type=Numeric
Declare Var=$BMP_ColorTransparent Type=Numeric
Declare Var=$BMP_CurrentCache Type=String
Declare Var=$BMP_DeltaLat Type=Numeric
Declare Var=$BMP_DeltaLatLon Type=Numeric
Declare Var=$BMP_DeltaLon Type=Numeric
Declare Var=$BMP_DisplayBackCheck Type=Boolean
Declare Var=$BMP_DisplayFrontCheck Type=Boolean
Declare Var=$BMP_DisplayLabels Type=Boolean
Declare Var=$BMP_DrawSymb Type=String
Declare Var=$BMP_GridLine Type=String
Declare Var=$BMP_icnt Type=Numeric
Declare Var=$BMP_LabelCount Type=Numeric
Declare Var=$BMP_labels Type=String
Declare Var=$BMP_LabelText Type=String
Declare Var=$BMP_lat Type=Numeric
Declare Var=$BMP_lat1 Type=Numeric
Declare Var=$BMP_lat2 Type=Numeric
Declare Var=$BMP_LinePos1 Type=Numeric
Declare Var=$BMP_LinePos2 Type=Numeric
Declare Var=$BMP_LineThick Type=Boolean
Declare Var=$BMP_lon Type=Numeric
Declare Var=$BMP_lon1 Type=Numeric
Declare Var=$BMP_lon2 Type=Numeric
Declare Var=$BMP_MaxLatDraw Type=Numeric
Declare Var=$BMP_MaxLonDraw Type=Numeric
Declare Var=$BMP_MinLatDraw Type=Numeric
Declare Var=$BMP_MinLonDraw Type=Numeric
Declare Var=$BMP_NrPixels Type=Numeric
Declare Var=$BMP_PixDelta Type=Numeric
Declare Var=$BMP_pixdifx Type=Numeric
Declare Var=$BMP_pixdify Type=Numeric
Declare Var=$BMP_PixMax Type=Numeric
Declare Var=$BMP_Segment Type=String
Declare Var=$BMP_ShowGridLines Type=Boolean
Declare Var=$BMP_TMPBool Type=Boolean
Declare Var=$BMP_TMPint Type=Numeric
Declare Var=$BMP_TMPstr Type=String
Declare Var=$BMP_TMPStrBack Type=String
Declare Var=$BMP_x Type=Numeric
Declare Var=$BMP_y Type=Numeric
Declare Var=$BMP620HeadMime Type=String
Declare Var=$BMP620square Type=String
Declare Var=$BMPkeeprunning Type=Boolean
Declare Var=$BMPlabelNE Type=String
Declare Var=$BMPlabelNW Type=String
Declare Var=$BMPlabelSE Type=String
Declare Var=$BMPlabelSW Type=String
Declare Var=$CacheCount Type=Numeric
Declare Var=$CenterLat Type=Numeric
Declare Var=$CenterLon Type=Numeric
Declare Var=$CumStr Type=String
Declare Var=$CurrentCount Type=Numeric
Declare Var=$DataRes Type=String
Declare Var=$DeLormeDraw_Folder Type=String
Declare Var=$DeLormeDrawCode Type=String
Declare Var=$DeLormeGPX_Filename Type=String
Declare Var=$DeLormeGPX_Folder Type=String
Declare Var=$DeLormeGPX_Footer Type=String
Declare Var=$DeLormeGPX_Header Type=String
Declare Var=$DeLormeGPX_String Type=String
Declare Var=$DeltaOnThisSide Type=Numeric
Declare Var=$FileOut Type=String
Declare Var=$FormExit Type=String
Declare Var=$FromStr Type=String
Declare Var=$GCcode Type=String
Declare Var=$GraphAreaBack Type=String
Declare Var=$GraphAreaFront Type=String
Declare Var=$GT_KeepRunning Type=Boolean
Declare Var=$GT_MagicNumber Type=Numeric
Declare Var=$GT_MaximumNumber Type=Numeric
Declare Var=$GT_MaxNrTilesPerBand Type=Numeric
Declare Var=$GTinstructions Type=String
Declare Var=$HardMaxEdit Type=String
Declare Var=$iBand Type=Numeric
Declare Var=$iCacheGroup Type=Numeric
Declare Var=$iCount Type=Numeric
Declare Var=$IncludeAddtnl Type=Boolean
Declare Var=$iTile Type=Numeric
Declare Var=$iTileMax Type=Numeric
Declare Var=$KMLFolder Type=String
Declare Var=$KMLpolygonsFoot Type=String
Declare Var=$KMLpolygonsHead Type=String
Declare Var=$KMLStr Type=String
Declare Var=$KMLtilePrefix Type=String
Declare Var=$KMLtileSuffix Type=String
Declare Var=$Limit Type=Numeric
Declare Var=$LineFeed Type=String
Declare Var=$MainForm Type=String
Declare Var=$MainFormWithLabels Type=String
Declare Var=$MaxLat Type=Numeric
Declare Var=$MaxLon Type=Numeric
Declare Var=$MaxLogNr Type=Numeric
Declare Var=$MaxLogNrEdit Type=String
Declare Var=$memo2 Type=String
Declare Var=$MinLat Type=Numeric
Declare Var=$MinLon Type=Numeric
Declare Var=$Offset Type=Numeric
Declare Var=$PauseForm Type=String
Declare Var=$PauseForm_Response Type=String
Declare Var=$PauseForm_YesNo Type=Boolean
Declare Var=$PauseFormMemo Type=String
Declare Var=$Referencelon Type=String
Declare Var=$RefLongitude Type=Numeric
Declare Var=$RegionName Type=String
Declare Var=$Remaining Type=Numeric
Declare Var=$RowNr Type=Numeric
Declare Var=$SaniString Type=String
Declare Var=$SetNameEdit Type=String
Declare Var=$SIDE Type=String
Declare Var=$SoftMaxEdit Type=String
Declare Var=$SQLfields Type=String
Declare Var=$SQLdatabase Type=String
Declare Var=$SQLqueryA Type=String
Declare Var=$SQLqueryB Type=String
Declare Var=$SQLresstr Type=String
Declare Var=$SQLresult Type=String
Declare Var=$StatusMessage Type=String
Declare Var=$TheLogs Type=String
Declare Var=$TileGCcodes Type=String
Declare Var=$TileGCcodesNR Type=Numeric
Declare Var=$TileSpecs Type=String
Declare Var=$TMPkml Type=String
Declare Var=$TmpLonMax Type=String
Declare Var=$TmpLonMin Type=String
Declare Var=$TmpStr Type=String
Declare Var=$TotalCacheCount Type=Numeric
Declare Var=$TotalCacheCountStr Type=String
Declare Var=$TotalCurrent Type=Numeric
Declare Var=$TotalNrCaches Type=Numeric
Declare Var=$TotalNrTiles Type=Numeric
Declare Var=$Version Type=String
Declare Var=$WhichWay Type=String
Declare Var=$xold Type=Numeric
Declare Var=$yold Type=Numeric

endsub
